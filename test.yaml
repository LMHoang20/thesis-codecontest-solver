---
points:
- name: Relevancy
    editorial: |
        In this problem we have an array $a_1, \ldots, a_n$, we can increase each $a_i$ by one with cost $t_i$, and we want to make all $a_i$ different with minimal total cost.
    code: |
        int n;
        cin >> n;
        for (int i = 0; i <= n - 1; i++) {
            cin >> ara[i].first;
        }
        for (int i = 0; i <= n - 1; i++) {
            cin >> ara[i].second;
        }
    add point: YES
- name: Core
    editorial: |
        Let's sort $a_i$ in a non-decreasing way (and permute the $t$ in a corresponding way). Let's see at the minimal number, $a_1$. If it is unique, e.g. $a_1 \ne a_2$, then we don't need to change $a_1$ â€” it is already unique, and it can't get equal to something else if we don't increase it.
    code: |
        sort(ara, ara + n, [](pair<int, int> x, pair<int, int> y) {
            return (x.first == y.first) ? x.second > y.second : x.first < y.first;
        });
    add point: YES
- name: Detail
    editorial: |
        This effectively reduces our problem to the smaller one, decreasing $n$ by one.
    code: |
        if (!que.empty()) {
            sum -= que.top();
            que.pop();
            prin += sum;
            cp++;
            i--;
        }
    add point: YES
- name: Perfect
    reasoning: |
        The code is splitted into two sections. The first section sorts the input and finds the minimum value of a_i. The second section implements the editorial's idea of increasing all other minimums by one and removing the maximum value t_l among all elements with minimal a_l.
    add point: YES
- name: Readability
    reasoning: |
        The code is short, uses a standard C++ library, and is easy to understand.
    add point: YES
